---
sidebar_position: 2
---

# Taxonomy â†” Catalog: AnÃ¡lisis de Acoplamiento

## ğŸ” Â¿Se puede asociar taxonomÃ­a a items?

**SÃ­, pero con acoplamiento en Infrastructure.** Vamos a desglosar.

---

## ğŸ“Š Arquitectura Actual

### Domain Level (SÃ­, hay desacoplamiento)

```
Catalog/Domain/Entities/Item.php
â”œâ”€â”€ termIds: string[]  â† Solo IDs, sin conocimiento de Taxonomy
â””â”€â”€ getTermIds(): array

Taxonomy/Domain/Entities/Term.php
â”œâ”€â”€ name, slug, vocabularyId
â””â”€â”€ NO conoce de Items
```

**Score**: âœ… Domain COMPLETAMENTE desacoplado
- Item almacena solo IDs de tÃ©rminos
- Item no importa clases de Taxonomy
- Taxonomy no sabe de Items

---

### Infrastructure Level (âš ï¸ Acoplamiento detectado)

```php
// app/Catalog/Infrastructure/Out/Models/EloquentItem.php
use App\Taxonomy\Infrastructure\Out\Models\Eloquent\TermModel;
                                     â†“
class EloquentItem extends Model {
    public function terms() {
        return $this->belongsToMany(
            TermModel::class,  // â† Acoplamiento AQUÃ
            'catalog_item_terms',
            'item_id',
            'term_id'
        );
    }
}
```

**Score**: âš ï¸ Infrastructure acoplado (pero aceptable)

---

## ğŸ”— Flujo de AsociaciÃ³n

### 1. Guardar Item con TÃ©rminos

```php
// EloquentItemRepository.php
public function save(Item $item): void {
    $model = EloquentItem::create([...]);
    
    // Sincronizar relaciÃ³n M:M
    if (!empty($item->getTermIds())) {
        $model->terms()->sync($item->getTermIds());
        //        â†‘ Eloquent relationship
    }
}
```

**Funcionamiento:**
```
Item.termIds = ["term-uuid-1", "term-uuid-2"]
                            â†“
        $model->terms()->sync([...])
                            â†“
        INSERT INTO catalog_item_terms (item_id, term_id)
        VALUES ("item-id", "term-uuid-1")
        VALUES ("item-id", "term-uuid-2")
```

### 2. Cargar Item con TÃ©rminos

```php
public function findById(string $id): ?Item {
    $model = EloquentItem::with('terms')->find($id);
    //                      â†‘ Eager load
    
    return $this->toDomain($model);
}

private function toDomain(EloquentItem $model): Item {
    return new Item(
        ...
        termIds: $model->terms->pluck('id')->toArray(),
        //              â†‘ Extrae solo IDs
    );
}
```

**Flujo:**
```
SELECT * FROM catalog_items WHERE id = ?
SELECT * FROM catalog_item_terms WHERE item_id = ?
SELECT * FROM catalog_terms WHERE id IN (...)
                            â†“
        $model->terms = [TermModel, TermModel, ...]
                            â†“
        termIds = ["term-uuid-1", "term-uuid-2"]
                            â†“
        Item(termIds: [...])
```

---

## âœ… Fortalezas

### 1. **Domain estÃ¡ limpio**
```php
// Item.php NUNCA importa Taxonomy
class Item {
    private array $termIds = [];  // Solo IDs
}
```

### 2. **La relaciÃ³n es flexible**
Item no sabe quÃ© son los tÃ©rminos. PodrÃ­an ser:
- CategorÃ­as de producto
- Marcas
- Colores
- Atributos
- Etiquetas
- Anything!

### 3. **Reversibilidad**
La tabla `catalog_item_terms` es una tabla de asociaciÃ³n pura:
```
catalog_item_terms (item_id, term_id)
    â†‘
    â””â”€ Ambas tablas conocen el UUID, pero no la estructura
```

---

## âš ï¸ Debilidades y Acoplamiento

### 1. **EloquentItem importa TermModel**

**ACTUAL (Acoplado):**
```php
// EloquentItem.php
use App\Taxonomy\Infrastructure\Out\Models\Eloquent\TermModel;

public function terms() {
    return $this->belongsToMany(TermModel::class, ...);
}
```

**Problema:** Si Taxonomy fuera microservicio remoto, esto falla.

**Mejor (Desacoplado):**
```php
// EloquentItem.php
public function terms() {
    return $this->belongsToMany(
        'App\Taxonomy\Infrastructure\Out\Models\Eloquent\TermModel',
        // String path, no importa TermModel
        'catalog_item_terms',
        'item_id',
        'term_id'
    );
}
```

O **aÃºn mejor**, usar tabla polimÃ³rfica:

```php
public function terms() {
    return $this->morphToMany(
        GenericTaxonomy::class,
        'taggable',
        'catalog_polymorphic_terms'
    );
}
```

### 2. **No hay validaciÃ³n de existencia de tÃ©rminos**

**SituaciÃ³n actual:**
```php
$item->setTermIds(["invalid-uuid"]);
$repository->save($item);  // â† Sin validar que el tÃ©rmino existe
```

**Resultado:** Foreign key constraint error en BD.

**Mejor:**
```php
public function save(Item $item): void {
    // Validar que tÃ©rminos existen
    $terms = TermModel::whereIn('id', $item->getTermIds())->get();
    
    if ($terms->count() !== count($item->getTermIds())) {
        throw new InvalidTermException('Some terms do not exist');
    }
    
    $model->terms()->sync($item->getTermIds());
}
```

### 3. **Cambios en Taxonomy rompen Catalog**

Si cambian la tabla o estructura de Taxonomy:
```
catalog_terms â†’ catalog_taxonomies    (breaking change)
                            â†“
        EloquentItem.terms() breaks
```

---

## ğŸ“ PatrÃ³n Actual vs Propuesto

### ACTUAL - Acoplamiento en Infra

```
Catalog Domain          Taxonomy Domain
    â”œâ”€ Item                â”œâ”€ Term
    â””â”€ termIds: []         â””â”€ vocabularyId
         (desacoplado)          (desacoplado)
              â†“                     â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ Catalog Infrastructure â”‚
         â”‚                        â”‚
         â”‚ EloquentItem â”€â”€usesâ”€â”€  â”‚
         â”‚ TermModel    (import)  â”‚
         â”‚                        â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              âš ï¸ Acoplamiento AQUÃ
```

### PROPUESTO - Desacoplamiento Total

#### OpciÃ³n 1: Usar Strings

```php
// EloquentItem.php
public function terms() {
    return $this->belongsToMany(
        'App\Taxonomy\Infrastructure\Out\Models\Eloquent\TermModel',
        'catalog_item_terms',
        'item_id',
        'term_id'
    );
}
```

**Beneficio:** No importa directamente, evita circular dependencies.

#### OpciÃ³n 2: Usar Portal para vinculaciÃ³n

```php
// CatalogTermGateway.php (Infrastructure)
interface CatalogTermGatewayInterface {
    public function linkTermsToItem(string $itemId, array $termIds): void;
    public function getItemTerms(string $itemId): array;
}

// PortalCatalogTermGateway.php
class PortalCatalogTermGateway implements CatalogTermGatewayInterface {
    public function linkTermsToItem(string $itemId, array $termIds): void {
        Portal::link($itemId, 'Item', 'Catalog', $termIds, 'Terms', 'Taxonomy');
    }
}
```

**Uso:**
```php
// EloquentItemRepository.php
public function save(Item $item): void {
    $model = EloquentItem::create([...]);
    
    // Usar gateway, NO relaciÃ³n Eloquent directa
    $this->termGateway->linkTermsToItem(
        $item->getId(),
        $item->getTermIds()
    );
}
```

**Beneficio:** Totally desacoplado, preparado para microservicios.

#### OpciÃ³n 3: RelaciÃ³n PolimÃ³rfica

```php
// Usar tabla neutral "item_tags" en lugar de "catalog_item_terms"

Schema::create('item_tags', function (Blueprint $table) {
    $table->id();
    $table->uuidMorphs('taggable');  // item_id + item_type
    $table->uuid('tag_id');
    $table->timestamps();
});

// EloquentItem.php
public function tags() {
    return $this->morphToMany(
        Tag::class,
        'taggable',
        'item_tags'  // Tabla neutral
    );
}
```

**Beneficio:** Permite categorizar CUALQUIER entidad (Items, Orders, Users, etc.).

---

## ğŸ—ï¸ Tabla Actual: catalog_item_terms

```sql
CREATE TABLE catalog_item_terms (
    item_id UUID,           -- Foreign Key â†’ catalog_items
    term_id UUID,           -- Foreign Key â†’ catalog_terms
    PRIMARY KEY (item_id, term_id)
);
```

**Diagrama:**
```
catalog_items
    â”‚
    â”œâ”€ id (PK)
    â”œâ”€ name
    â”œâ”€ description
    â””â”€ ...

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ catalog_item_terms   â”‚
        â”‚ (tabla de relaciÃ³n)  â”‚
        â”‚ item_id â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”   â”‚
        â”‚ term_id â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚
catalog_terms â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â”œâ”€ id (PK)
    â”œâ”€ name (ej: "ElectrÃ³nica")
    â”œâ”€ vocabulary_id
    â””â”€ ...
```

---

## ğŸ¯ Recomendaciones

### Corto Plazo (Inmediato)

âœ… **Mantener como estÃ¡** - Funciona correctamente.

### Mediano Plazo

1. **ValidaciÃ³n de tÃ©rminos:**
```php
// EloquentItemRepository.php
public function save(Item $item): void {
    if (!empty($item->getTermIds())) {
        // Validar que tÃ©rminos existen
        $exists = TermModel::whereIn('id', $item->getTermIds())
                    ->count() === count($item->getTermIds());
        
        if (!$exists) {
            throw new TermNotFoundException();
        }
    }
    // ... resto del cÃ³digo
}
```

2. **Usar strings para imports (menor acoplamiento):**
```php
// EloquentItem.php
return $this->belongsToMany(
    'App\Taxonomy\Infrastructure\Out\Models\Eloquent\TermModel',
    // En lugar de: use TermModel; belongsToMany(TermModel::class)
```

### Largo Plazo

1. **Implementar Gateway patrÃ³n:**
```php
// ItemRepositoryInterface con mÃ©todo para tÃ©rminos
interface ItemRepositoryInterface {
    public function setTermGateway(TermGatewayInterface $gateway): void;
}
```

2. **Considerar Portal si Taxonomy es remoto:**
```php
// Cuando Taxonomy sea otro servicio
Portal::link('item-id', 'Item', 'Catalog', 'terms', [...], 'Taxonomy');
```

---

## ğŸ“ˆ Score de Desacoplamiento

| Aspecto | Score | Estado |
|---------|-------|--------|
| Domain desacoplado | 9/10 | âœ… Excelente |
| Infrastructure desacoplado | 6/10 | âš ï¸ Acoplado (aceptable) |
| Validaciones presentes | 4/10 | âš ï¸ Falta validaciÃ³n |
| Preparado para cambios | 6/10 | âš ï¸ Requiere refactoring |
| Testeable | 8/10 | âœ… Bueno |
| **Total** | **6.6/10** | âš ï¸ Funciona, mejorable |

---

## âœ… ConclusiÃ³n

### Â¿Se puede asociar taxonomÃ­a a items?
**SÃ­, perfectamente.** Item tiene `termIds`, se sincroniza con Taxonomy en BD.

### Â¿EstÃ¡ bien desacoplado?
**Parcialmente.**
- âœ… Domain: Perfecto desacoplamiento
- âš ï¸ Infrastructure: Acoplado mediante imports directos de TermModel

### Â¿CuÃ¡l es el riesgo?
**Bajo-Medio:** Solo afecta Infrastructure. Si Taxonomy cambia de ubicaciÃ³n/BD, EloquentItem.terms() necesita actualizaciÃ³n.

### Â¿QuÃ© hacer?
1. Corto plazo: Agregar validaciÃ³n de existencia de tÃ©rminos
2. Mediano plazo: Usar strings para imports o tabla polimÃ³rfica
3. Largo plazo: Gateway pattern si Taxonomy es remoto
