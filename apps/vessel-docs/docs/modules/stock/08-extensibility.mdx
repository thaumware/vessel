---
sidebar_position: 8
---

# Extensibility (Tipos Custom de Movimiento)

Sistema de **Movement Handlers** para agregar tipos de movimiento personalizados **sin modificar el c√≥digo core**.

## üéØ Problema que Resuelve

**Antes**: Para agregar un tipo de movimiento (ej: pr√©stamos, consignaci√≥n, reparaciones), hab√≠a que:
1. Modificar el enum `MovementType`
2. Modificar validaciones hardcodeadas
3. Desplegar c√≥digo core

**Ahora**: Crea un **Handler** en Infrastructure y reg√≠stralo. Listo.

---

## üèóÔ∏è Arquitectura

### Domain (R√≠gido - NO modificar)

```php
enum MovementType {
    RECEIPT, RETURN, SHIPMENT, RESERVE, RELEASE, ...
    CUSTOM  // ‚Üê Tipo gen√©rico para extensiones
}

interface MovementHandlerInterface {
    supports(string $type): bool
    validate(Movement, StockItem): void
    handle(Movement, StockItem): StockItem
}
```

### Infrastructure (Flexible - EXTENDER aqu√≠)

```php
class MovementHandlerRegistry {
    register(MovementHandlerInterface $handler)
}

// Handlers ejemplo incluidos:
CustomerLoanHandler       // customer_loan, loan_return
ConsignmentHandler        // consignment_out, consignment_return
```

---

## ‚úÖ C√≥mo Agregar un Tipo Custom

### 1. Crear el Handler

```php title="app/Stock/Infrastructure/Handlers/RepairInHandler.php"
<?php

namespace App\Stock\Infrastructure\Handlers;

use App\Stock\Domain\Interfaces\MovementHandlerInterface;
use App\Stock\Domain\Entities\Movement;
use App\Stock\Domain\Entities\StockItem;

class RepairInHandler implements MovementHandlerInterface
{
    public function supports(string $movementType): bool
    {
        return $movementType === 'repair_in';
    }

    public function validate(Movement $movement, StockItem $stockItem): void
    {
        // Validaciones custom
        $meta = $movement->getMeta();
        if (!isset($meta['repair_order_id'])) {
            throw new \DomainException('repair_order_id es requerido en meta');
        }
    }

    public function handle(Movement $movement, StockItem $stockItem): StockItem
    {
        // IMPORTANTE: StockItem es inmutable, retornar nuevo objeto
        return $stockItem->adjustQuantity($movement->getQuantity());
    }

    public function describe(): string
    {
        return 'Repair In Handler: Entrada de items desde reparaci√≥n';
    }
}
```

### 2. Registrar en ServiceProvider

```php title="app/Stock/Infrastructure/StockServiceProvider.php"
$this->app->singleton(MovementHandlerRegistry::class, function ($app) {
    $registry = new MovementHandlerRegistry();
    
    // ‚úÖ AGREGAR TU HANDLER AQU√ç
    $registry->register(new RepairInHandler());
    
    return $registry;
});
```

### 3. Usar desde API

```http
POST /api/v1/stock/movements
Content-Type: application/json

{
  "type": "custom",
  "reference_type": "repair_in",
  "item_id": "ITEM-001",
  "location_id": "SERVICE-CENTER",
  "quantity": 1,
  "meta": {
    "repair_order_id": "RO-12345",
    "technician": "John Doe",
    "condition": "refurbished"
  }
}
```

---

## üì¶ Handlers Incluidos (Ejemplos)

### CustomerLoanHandler

Maneja pr√©stamos a cliente y devoluciones.

**Tipos soportados**: `customer_loan`, `loan_return`

#### Pr√©stamo

```http
POST /api/v1/stock/movements

{
  "type": "custom",
  "reference_type": "customer_loan",
  "item_id": "ITEM-001",
  "location_id": "WAREHOUSE-MAIN",
  "quantity": 5,
  "meta": {
    "customer_id": "CUST-123",
    "expected_return_date": "2024-12-31",
    "loan_type": "demo"
  }
}
```

**Comportamiento**: RESTA stock (como shipment) pero con metadata de pr√©stamo.

#### Devoluci√≥n de Pr√©stamo

```http
POST /api/v1/stock/movements

{
  "type": "custom",
  "reference_type": "loan_return",
  "item_id": "ITEM-001",
  "location_id": "WAREHOUSE-MAIN",
  "quantity": 5,
  "reference_id": "LOAN-2024-001"
}
```

**Comportamiento**: SUMA stock (devoluci√≥n).

---

### ConsignmentHandler

Maneja env√≠os en consignaci√≥n y devoluciones.

**Tipos soportados**: `consignment_out`, `consignment_return`

#### Env√≠o en Consignaci√≥n

```http
POST /api/v1/stock/movements

{
  "type": "custom",
  "reference_type": "consignment_out",
  "item_id": "ITEM-001",
  "location_id": "WAREHOUSE-MAIN",
  "quantity": 20,
  "meta": {
    "consignee": "RETAIL-STORE-001",
    "agreement_expires": "2025-01-31"
  }
}
```

**Comportamiento**: RESTA stock (salida a consignatario).

#### Devoluci√≥n de Consignaci√≥n

```http
POST /api/v1/stock/movements

{
  "type": "custom",
  "reference_type": "consignment_return",
  "item_id": "ITEM-001",
  "location_id": "WAREHOUSE-MAIN",
  "quantity": 8,
  "meta": {
    "sold": false,
    "reason": "No vendido en tienda"
  }
}
```

**Comportamiento**: SUMA stock (no se vendi√≥, vuelve).

---

## üîë Puntos Clave

### 1. MovementType::CUSTOM es Gen√©rico

- NO modifica el enum
- `referenceType` identifica el tipo espec√≠fico
- Mantiene type safety en Domain

### 2. StockItem es INMUTABLE

```php
// ‚ùå MAL
public function handle(Movement $movement, StockItem $stockItem): StockItem
{
    $stockItem->quantity -= 10; // ‚ùå No funciona (propiedad readonly)
    return $stockItem;
}

// ‚úÖ BIEN
public function handle(Movement $movement, StockItem $stockItem): StockItem
{
    return $stockItem->adjustQuantity(-10); // ‚úÖ Retorna nuevo objeto
}
```

### 3. Validaci√≥n Custom

```php
public function validate(Movement $movement, StockItem $stockItem): void
{
    // Lanza DomainException si falla
    if ($stockItem->getAvailableQuantity() < $movement->getQuantity()) {
        throw new \DomainException('Stock insuficiente para pr√©stamo');
    }
    
    // Validar metadata
    $meta = $movement->getMeta();
    if (!isset($meta['customer_id'])) {
        throw new \DomainException('customer_id requerido para pr√©stamos');
    }
}
```

### 4. Handlers son Opcionales

- Si NO hay handler para `referenceType`, usa l√≥gica est√°ndar del enum
- Puedes registrar m√∫ltiples handlers (coexisten)
- Tipos est√°ndar siguen funcionando normalmente

---

## üéì Cu√°ndo Usar Qu√©

### Usar Enum Est√°ndar

‚úÖ Movimientos comunes (receipt, shipment, return, reserve, etc.)  
‚úÖ Sin validaciones especiales  
‚úÖ Comportamiento est√°ndar (suma/resta stock)

**Ejemplo**:
```json
{
  "type": "receipt",
  "item_id": "ITEM-001",
  "quantity": 100
}
```

---

### Usar Handler Custom

‚úÖ L√≥gica de negocio especial  
‚úÖ Validaciones complejas (ej: validar contra API externa)  
‚úÖ Metadata custom requerida  
‚úÖ Comportamiento condicional

**Ejemplo**:
```json
{
  "type": "custom",
  "reference_type": "repair_in",
  "meta": {"repair_order_id": "RO-123"}
}
```

---

### Usar Meta + ReferenceType (sin handler)

‚úÖ Solo necesitas metadata extra  
‚úÖ Comportamiento est√°ndar (suma/resta)  
‚úÖ No requiere validaciones custom

**Ejemplo**:
```json
{
  "type": "shipment",
  "reference_type": "demo_shipment",
  "meta": {
    "is_demo": true,
    "customer_type": "trial"
  }
}
```

---

## üß™ Testing

Los handlers custom son completamente testeables:

```php title="CustomMovementHandlersTest.php"
public function test_custom_loan_handler_reduces_stock(): void
{
    $movement = new Movement(
        type: MovementType::CUSTOM,
        itemId: 'ITEM-001',
        locationId: 'WAREHOUSE-MAIN',
        quantity: 5,
        referenceType: 'customer_loan',
        meta: ['customer_id' => 'CUST-123']
    );

    $service = new StockMovementService(
        customHandlers: [new CustomerLoanHandler()]
    );

    $result = $service->process($movement);

    $this->assertTrue($result->isSuccess());
    $this->assertEquals(95, $result->getStockItem()->getQuantity());
}
```

**Tests incluidos**: 7 tests, 17 assertions ‚úÖ PASSING

---

## üîß Activar Handlers Ejemplo

En `StockServiceProvider.php`:

```php
$registry = new MovementHandlerRegistry();

// ‚úÖ DESCOMENTA PARA ACTIVAR
$registry->register(new CustomerLoanHandler());
$registry->register(new ConsignmentHandler());

return $registry;
```

---

## üìä Comparaci√≥n

| Aspecto | Antes | Ahora |
|---------|-------|-------|
| **Agregar tipo** | Modificar enum + deploy | Crear handler + registrar |
| **Validaciones custom** | ‚ùå Hardcodeadas en service | ‚úÖ En handler |
| **Deploy requerido** | ‚úÖ S√≠ (c√≥digo core) | ‚ö†Ô∏è Solo si es nuevo handler |
| **Testing** | ‚ùå Acoplado | ‚úÖ Aislado por handler |
| **Tipos soportados** | 18 fijos | 18 + ‚àû custom |

---

## ‚úÖ Checklist: Agregar Tipo Custom

- [ ] Crear `MyCustomHandler.php` en `app/Stock/Infrastructure/Handlers/`
- [ ] Implementar `supports(string $movementType): bool`
- [ ] Implementar `validate(Movement, StockItem): void`
- [ ] Implementar `handle(Movement, StockItem): StockItem` (retornar nuevo StockItem)
- [ ] Implementar `describe(): string`
- [ ] Registrar en `StockServiceProvider::register()`
- [ ] Crear test en `Tests/Feature/`
- [ ] Documentar en README del proyecto

---

## üèóÔ∏è Arquitectura Interna

### Flujo de Procesamiento

```
1. Movement recibido con type: CUSTOM
   ‚îî‚îÄ> StockMovementService.process()
       
2. ¬øEs CUSTOM?
   ‚îî‚îÄ> S√ç: Buscar handler por referenceType
       ‚îî‚îÄ> Handler encontrado?
           ‚îú‚îÄ> S√ç: handler.validate() ‚Üí handler.handle()
           ‚îî‚îÄ> NO: L√≥gica est√°ndar del enum
           
   ‚îî‚îÄ> NO: L√≥gica est√°ndar del enum (addsStock/removesStock)
```

### Separaci√≥n de Responsabilidades

| Capa | Responsabilidad |
|------|-----------------|
| **Domain** | Enum cerrado (18 tipos + CUSTOM) |
| **Handler** | L√≥gica custom por tipo |
| **Registry** | Registro de handlers |
| **Service** | Detecta CUSTOM y delega a handler |

‚úÖ **Domain** no conoce tipos custom espec√≠ficos  
‚úÖ **Infrastructure** agrega funcionalidad sin modificar core

---

## üìù Resumen

**Domain** = R√≠gido (18 tipos enum + CUSTOM gen√©rico)  
**Infrastructure** = Flexible (handlers ilimitados)  
**Extensi√≥n** = F√°cil (crear handler + registrar)  
**Testing** = 7 tests passing ‚úÖ  
**Type Safety** = Preservado (enum sigue cerrado)

**Handlers incluidos**:
- `CustomerLoanHandler` (pr√©stamos)
- `ConsignmentHandler` (consignaci√≥n)

**Ready to extend**: Crea tu handler en 5 minutos.
